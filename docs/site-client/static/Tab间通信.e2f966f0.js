var e={html:'<h1 id="tab-间通信">Tab 间通信</h1>\n<p>同源网站，不同 Tab 之间通信，三种方式：</p>\n<ul>\n<li>windows.postMessage</li>\n<li>localstorage</li>\n<li>BroadcastChannel</li>\n</ul>\n<h1 id="postmessage">postMessage</h1>\n<p>当使用 window.open 打开一个新页面时，若两个 Tab 之间需要通信，则可以使用<code>window.postMessage</code>实现通信。</p>\n<p>场景：在<code>A页面</code>使用<code>window.open</code>打开<code>B页面</code>，在<code>B页面</code>向<code>A页面</code>发送消息。</p>\n<p>原理：</p>\n<ul>\n<li>A 页面监听<code>message</code>事件</li>\n<li>B 页面使用<code>postMessage</code>发送消息</li>\n</ul>\n<p>具体实现(<a href="https://github.com/swlws/swlws.github.io/blob/master/shared/tool/tab-message.ts">源码</a>)：</p>\n<p>A 页面监听消息</p>\n<pre><code class="ts language-ts">/**\n * 事件映射\n */\nconst eventMap: PlainObject = {};\n\nwindow.addEventListener(\'message\', (ev) =&gt; {\n  let { data } = ev;\n  if (Object.prototype.toString.call(data) !== \'[object Object]\') return;\n\n  let { key, args = [] } = data;\n  let fn = eventMap[key];\n  if (typeof fn === \'function\') {\n    if (!Array.isArray(args)) args = [args];\n    fn(...args);\n  }\n});\n\n/**\n * 注册Tab页事件\n *\n * @param key\n * @param fn\n */\nexport function registerTabEvent(key: string, fn: (...args: any[]) =&gt; void) {\n  eventMap[key] = fn;\n}</code></pre>\n<p>B 页面发送消息</p>\n<pre><code class="ts language-ts">type TMessage = { key: string; args?: any[] };\n/**\n * 发送消息\n *\n * @param data\n * @returns\n */\nexport function sendTabMessage(data: TMessage) {\n  let opener = window.opener;\n  if (!opener) return;\n\n  opener.postMessage(data, \'/\');\n}</code></pre>\n<h1 id="localstorage">localstorage</h1>\n<p>localstorage 可以存储浏览器数据，同源时，共享数据。当使用<code>setItem</code>设置数据时，<code>storage</code>事件可以监听到数据的变化（必须是不同的 Tab 页）</p>\n<p>原理也是 window 的监听事件，实现与 postMessage 类似</p>\n<h1 id="broadcastchannel">BroadcastChannel</h1>',metadata:{},filename:"Tab间通信.md",path:"/Users/sunwenlong/Self/Code/10-MyGit/swlws.github.io/packages/site-client/src/views/menu/doc-list/md/Tab间通信.md"};export default e;

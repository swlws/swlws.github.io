import{_ as n,E as r,c as l,b as i,w as e,a3 as c,a2 as o,o as a,J as s,a as d}from"./chunks/framework.BNFXvbzm.js";const p="/assets/pico.D3WGm2x3.png",C=JSON.parse('{"title":"Web Component 转图片","description":"双周回顾","frontmatter":{"outline":"deep","head":[["meta",{"name":"author","content":"swlws"}],["meta",{"name":"description","content":"双周回顾"}],["meta",{"name":"keywords","content":"swlws 双周回顾 clone node deep html2canvas dom-to-image pico"}]]},"headers":[],"relativePath":"date/202403/clone-node-deep.md","filePath":"date/202403/clone-node-deep.md","lastUpdated":1709374849000}'),h={name:"date/202403/clone-node-deep.md"},m=o('<h1 id="web-component-转图片" tabindex="-1">Web Component 转图片 <a class="header-anchor" href="#web-component-转图片" aria-label="Permalink to &quot;Web Component 转图片&quot;">​</a></h1><p><img src="'+p+'" alt="pico"></p><h2 id="一、html-转图片" tabindex="-1">一、HTML 转图片 <a class="header-anchor" href="#一、html-转图片" aria-label="Permalink to &quot;一、HTML 转图片&quot;">​</a></h2><p>目前，常见的开源的能够将 HTML 转换为图片有<code>html2canvas</code>、<code>dom-to-image</code>，大部分场景下，这些开源库都能很友好的处理。</p><p>HTML 转图片的实现原理，通常分为两种：<code>svg</code> 与 <code>canvas</code>。今天主要讨论下 <code>svg</code> 的场景，它的处理流程一般为：</p>',5),_=o('<h2 id="二、svg-模式存在的问题" tabindex="-1">二、svg 模式存在的问题 <a class="header-anchor" href="#二、svg-模式存在的问题" aria-label="Permalink to &quot;二、svg 模式存在的问题&quot;">​</a></h2><p>普通的 DOM 节点这么处理，一般没啥大问题。唯独遇见 Web Component 时，XMLSerializer 的处理过程会造成 ShadowRoot 解析失败。</p><p>表现的行为就是，绘制出的图片中，Web Component 所在的位置是一片空白。</p><h2 id="三、解决方案设计" tabindex="-1">三、解决方案设计 <a class="header-anchor" href="#三、解决方案设计" aria-label="Permalink to &quot;三、解决方案设计&quot;">​</a></h2><p><code>XMLSerializer.serializeToString</code> 对 Web Component 的影响：</p><ol><li>如果 Web Component 的关键内容位于其 Shadow DOM 中，那么使用 XMLSerializer 序列化后，这些内容将不会包含在生成的 XML 字符串中，导致信息丢失</li><li>如果 Web Component 的样式信息位于 Shadow DOM 中，使用 XMLSerializer 序列化后，样式信息也将丢失，导致外部无法正确地应用样式</li></ol><p>定位到问题后，则大致的处理方案为：</p><ol><li>将 Web Component 解析为普通的 DOM 节点，将 ShadowRoot 下的节点拷贝至 DOM 节点中</li><li>处理 ShadowRoot 的 style 节点，防止样式造成全局污染</li></ol><h2 id="四、方案实现" tabindex="-1">四、方案实现 <a class="header-anchor" href="#四、方案实现" aria-label="Permalink to &quot;四、方案实现&quot;">​</a></h2><p><a href="https://www.npmjs.com/package/@gripeless/pico" target="_blank" rel="noreferrer">npm - @gripeless/pico</a> 是一个基于 svg 实现的、轻量级的 HTML 转图片的库，大小 <code>99.3 KB</code></p><p><a href="https://www.npmjs.com/package/@swl/clone-node-deep" target="_blank" rel="noreferrer">@swl/clone-node-deep</a> 是一个兼容 Web Component 拷贝的开源库，大小为 <code>10.6KB</code></p><p>二者相配合，即可实现兼容 Web Component 的图片绘制场景。</p><h2 id="五、引用" tabindex="-1">五、引用 <a class="header-anchor" href="#五、引用" aria-label="Permalink to &quot;五、引用&quot;">​</a></h2><ul><li><a href="https://github.com/rsify/pico" target="_blank" rel="noreferrer">github - pico 源码</a></li><li><a href="https://github.com/swlws/cloneNodeDeep" target="_blank" rel="noreferrer">github - @swl/clone-node-deep 源码</a></li></ul>',14);function b(g,u,f,w,S,T){const t=r("Mermaid");return a(),l("div",null,[m,(a(),i(c,null,{default:e(()=>[s(t,{id:"mermaid-15",class:"mermaid my-class",graph:"graph%20LR%0A%20%20A(%E7%AB%99%E7%82%B9HTML)%20--cloneNode--%3E%20B(%E6%8B%B7%E8%B4%9D%E5%87%BA%E7%9A%84DOM%E6%A0%91)%20----%3E%20C(foreignObject)%20---%3E%20D(XMLSerializer)%20--serializeToString--%3E%20E(new%20Image)%20----%3E%20F(canvas)----%3E%20G(Blob)%0A"})]),fallback:e(()=>[d(" Loading... ")]),_:1})),_])}const E=n(h,[["render",b]]);export{C as __pageData,E as default};

import{_ as i,E as t,c as l,J as o,w as n,m as a,a as e,a2 as d,o as c}from"./chunks/framework.BNFXvbzm.js";const h="/assets/struct.Br_Nri3S.png",x=JSON.parse('{"title":"JavaScript 的内存管理","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"date/202301/js内存/readme.md","filePath":"date/202301/js内存/readme.md"}'),r={name:"date/202301/js内存/readme.md"},p=a("h1",{id:"javascript-的内存管理",tabindex:"-1"},[e("JavaScript 的内存管理 "),a("a",{class:"header-anchor",href:"#javascript-的内存管理","aria-label":'Permalink to "JavaScript 的内存管理"'},"​")],-1),k=a("p",null,"JavaScript 是一个弱类型的、动态语言，在执行一段 JS 代码时，需要经历编译、执行、内存回收阶段。",-1),E=a("h2",{id:"一、编译阶段",tabindex:"-1"},[e("一、编译阶段 "),a("a",{class:"header-anchor",href:"#一、编译阶段","aria-label":'Permalink to "一、编译阶段"'},"​")],-1),_=a("img",{src:h},null,-1),u=d(`<p>JS 代码执行时，会首先创建<code>全局执行上下文</code>、以及<code>函数执行上下文</code>，上下文的执行顺序按照栈的方式进行调用，所以也叫做<code>函数调用栈</code>。</p><p>创建上下文时，会执行编译阶段，这一阶段会确定<code>作用域</code>，作用域确定了上下文有权限、且按一定的顺序访问的变量、函数。</p><p>进入一个上下文时，会经历<code>变量环境</code>的创建、初始化、赋值，这就导致了常见的变量提升问题。若是<code>ES6</code>环境时，还会额外多出词法环境，用于存储<code>ES6</code>的声明。</p><h2 id="二、栈、堆" tabindex="-1">二、栈、堆 <a class="header-anchor" href="#二、栈、堆" aria-label="Permalink to &quot;二、栈、堆&quot;">​</a></h2><p>执行上下文存储于栈，引用对象存储于堆。</p><p>当遇见引用对象时，栈中存储的是对象在堆中的地址。所以会有这么一个现象：当将对象复制给一个变量时，修改另一个对象时，原对象的值也会发生变化。示例：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;xxx&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;yyy&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// {name: &#39;yyy&#39;}</span></span></code></pre></div><h2 id="三、内存" tabindex="-1">三、内存 <a class="header-anchor" href="#三、内存" aria-label="Permalink to &quot;三、内存&quot;">​</a></h2><p>JS 的内存分配是动态，不需要事先申请，同时内存也是自动释放、不需要手动释放。</p><p><code>栈</code>占用的内存会随着上下文的执行结束而释放，<code>堆</code>占用的内存使用另一套机制。</p><p>V8 将<code>堆空间</code>分为两个区域:</p><ul><li><code>新生代</code>。存放生存<code>时间短</code>的对象；空间小，一般<code>1～8M</code>。</li><li><code>老生代</code>。存放生存<code>时间久</code>的对象；空间大。</li></ul><p>通用的垃圾回收流程：</p><ol><li>标记活动对象和非活动对象</li><li>清理非活动对象占据的内存</li><li>内存整理</li></ol><h3 id="_3-1-新生代垃圾回收策略" tabindex="-1">3.1 新生代垃圾回收策略 <a class="header-anchor" href="#_3-1-新生代垃圾回收策略" aria-label="Permalink to &quot;3.1 新生代垃圾回收策略&quot;">​</a></h3><p>采用 <code>Scavenge 算法</code>，基本原理：</p><ul><li>将空间对半分为对象区域和空闲区域</li><li>当对象区域快满时，执行一次清理过程</li><li>为对象区域的垃圾做标记，将存活的对象有序地、复制到到空闲区域，然后清空对象区域</li><li>对象区域、空闲区域角色反转，等待下一次清理流程</li></ul><p>备注：当经过两次垃圾回收依然还存活的对象，会被移动到老生代区域，即<code>对象晋升策略</code>。</p><h3 id="_3-2-老生代垃圾回收策略" tabindex="-1">3.2 老生代垃圾回收策略 <a class="header-anchor" href="#_3-2-老生代垃圾回收策略" aria-label="Permalink to &quot;3.2 老生代垃圾回收策略&quot;">​</a></h3><h4 id="a-策略" tabindex="-1">A. 策略 <a class="header-anchor" href="#a-策略" aria-label="Permalink to &quot;A. 策略&quot;">​</a></h4><p>依然采用标记清除策略，标记存活对象，清除垃圾。</p><p>与新生代回收策略不同的是，不会分两个区域（对象区域、空闲区域）。所以，当清理垃圾后，存储空间不是连续的，需要执行<code>整理</code>过程。</p><h4 id="b-影响" tabindex="-1">B. 影响 <a class="header-anchor" href="#b-影响" aria-label="Permalink to &quot;B. 影响&quot;">​</a></h4><p>垃圾回收器的执行是占用<code>主线程</code>的，即会阻塞<code>JavaScript</code>的执行，当垃圾回收执行结束，再恢复脚本执行。这种行为叫做<code>全停顿（stop-the-world）</code>。</p><h4 id="c-优化" tabindex="-1">C. 优化 <a class="header-anchor" href="#c-优化" aria-label="Permalink to &quot;C. 优化&quot;">​</a></h4><p>为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为<code>增量标记（Incremental Marking）算法</code>。</p>`,26);function m(g,b,y,f,v,q){const s=t("center");return c(),l("div",null,[p,k,E,o(s,null,{default:n(()=>[_]),_:1}),u])}const F=i(r,[["render",m]]);export{x as __pageData,F as default};
